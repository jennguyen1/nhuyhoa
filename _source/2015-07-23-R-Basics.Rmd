---
layout: post
title: "R Basics"
date: "July 23, 2015"
categories: ['basics']
---

* TOC
{:toc}


# Brief Overview of Data Structures

## Vectors
Vectors are one-dimensional arrays.

They are declared like so
```{r, eval = FALSE}
c(..., ...)
```

In R, objects are indexed starting from 1. For example, `x[1:5]`.

All elements in a vector should be one type. There are functions in R that can check or convert vector types:

* `is.numeric()`, `is.logical()`, `is.character()`, `is.factor()`
* `as.numeric()`, `as.logical()`, `as.character()`, `as.factor()`

Some built-in R functions are vectorized, element-wise operations. Examples of these include arithmetic functions, relational comparisons, etc.

Some useful functions for vectors include `seq(from, to, by)`, `sample(x, size, replace, prob)`, `which()`, `%in%`, `order()`, `sort()`, `quantile()`, `cut()`, and `table()`.

## Matrices
Matrices are multi-dimensional arrays. 

They are declared like so
```{r, eval = FALSE}
matrix( c(...), nrow = , ncol = , byrow = )
cbind(...) # combine vectors as columns
rbind(...) # combine vectors as rows
```

Similar to vectors, arrays may be numeric, logical, or character, but it must be all one type. Matrices also have vectorized functions. 

Extract elements from matrices using commas to separate the dimensions, `m[1:4, 10:4]`. If one dimension is not specified, the entire row/column is extracted. 

Matrices can be multipled using `%*%` or divided using `solve(a, b)` (If b isn't supplied, `solve` computes the inverse). Additional functions include `t()` for the transpose. Additional matrix operations are available in the `Matrix` package. 

## Data Frames
Data frames are two-dimensional structures where columns may be different types. The lengths of all columns must be equal.

Data frames can be declared like so
```{r, eval = FALSE}
data.frame(x1 = ..., x2 = ..., ...)
```

Data frames can be indexed and edited in similar ways to matrices. Here are a few examples `df[1:10, 3]`, `df[,2]`, `df$x`, `df[,"x"]`. 

Some useful functions to use with data frames include `dim()`, `nrow()`, `ncol()`, `head()`, `tail()`, `colnames()`, `str()`, `summary()`.

Data tables are an alternative to data frames that allow for optimized operations. They are available in `data.table` package. Data tables may differ from data frames in some indexing aspects.

There are other data frames that allow for more flexibility in types allowed in data.frames. Both `dplyr` and `Bioconductor` has options for these types of data structures. 

## Lists
A list is the free-for-all data structure. It is like a data frame but is not limited by any length restrictions. Lists can hold any data structure, including other lists. 

Lists are declared like so
```{r, eval = FALSE}
list(x1 = ..., x2 = ..., ...)
```


Lists can be indexed by number `l[[1]]` or by name `l$apple`, `l[["apple"]]`. Lists cannot be sliced, so loops should be used to subset a list. See [Apply and Parallel Processing][apply_post]{:target = "_blank"} post.

## Special Values

`NULL` is a null object. To test whether an object is `NULL`, use `is.null()`

`NA` is a missing value. To test whether an object is `NA`, use `is.na()`

# Conditionals

**Format for if/else**
{% highlight r%}
if (CONDITION) {
  # OPERATIONS
} else if (CONDITION) {
  # OPERATIONS
} else{
  # OPERATIONS
}
{% endhighlight%}

{% highlight r%}
ifelse(CONDITION, TRUE_ACTION, FALSE_ACTION)
{% endhighlight%}

**Format for switch statements**
{% highlight r%}
switch(VAR,
  opt_1 = {
    # OPERATIONS
  }, 
  opt_2 = {
    # OPERATIONS
  },
  opt_3 = {
    # OPERATIONS
  }
)
{% endhighlight%}

The code will execute different things depending on the value of $$VAR$$.

# Loops

**For Loops**
{% highlight r%}
for (LOOP_VAR in SEQUENCE) {
  # OPERATIONS
}
{% endhighlight%}

**While Loops**
{% highlight r%}
while(CONDITION){
  # OPERATIONS
}
{% endhighlight%}

**Control Within Loops**

* Skip to next iteration: `next`
* Exit loop: `break`

# Functions

{% highlight r%}
# declare function
FUNC_NAME <- function(PARAMS){
  # OPERATIONS
  # check for missing args - returns boolean
  missing(ARG)
  # invisible copy of object
  invisible(OBJ)
  # return (only 1 allowed) object
  return(OBJ)
}

# call function
FUNC_NAME(ARGS)
{% endhighlight%}

{% highlight r%}
# binary operators as functions
'%SYMBOL%' <- function(X, Y){}

# call function 
x %SYMBOL% y
{% endhighlight%}

## Pass undefined arguments 
We can allow for extra arguments that can be passed on to other functions. 

{% highlight r%}
f <- function(param1, param2, ...){
  # OPERATIONS
  # run another function with additional args
  func(...)
  # OPERATIONS
}
{% endhighlight%}

In addition, can also save extra args in a list
{% highlight r%}
list (...)
{% endhighlight%}

or use the nth unmatched argument
{% highlight r%}
..n
{% endhighlight%}

## Calling functions with a list of arguments
{% highlight r%}
do.call(FUN, NAMED_LIST)
{% endhighlight%}

## Find a function by name
{% highlight r%}
match.fun("FUN")
{% endhighlight%}

# IO

We can navigate through the file system of the computer like so.
```{r, eval = FALSE}
getwd() # get working directory
setwd() # set working directory
dir.create(DIR) # create a new directory
list.files(DIR, pattern = REGEX, full.names = TRUE) # obtain file paths for all files in DIR
file.exists(PATH) # check whether file exists
```

## Input

There are many ways to get data into R. 

**From a File**
```{r, eval = FALSE}
read.csv()
data.table::fread()
readxl::excel_sheets()
readxl::read_excel()
```

**Additional Options**

* `scan()` reads in user input
* Connecting to a SQL server (like `RODBC`)
* Scraping data from the internet (scrapeR and XML)

## Output

Options for file output include

* `write.csv()`
* `pdf()`, `jpg()`, `png()`, etc
* `RODBC::sqlSave()`

The last set of functions generate a document, after which one can print objects, and then close with the function `dev.off()`.

Another option is to use `knitr` to generate documents that incorporate R code, output, and Latex. This can be done via RStudio.

## Command Line Arguments

**Inputs**

The best option for using command line arguments is to use `optparse`.

```{r, eval = FALSE}
# add shebang command on top of the script
#!/usr/local/bin/Rscript

# open the library
library(optparse)

# declare the arguments in the file
option_list <- list(
  make_option("--generator", default="rnorm", help = "Function to generate random deviates [default \"%default\"]"),
  make_option(c("-c", "--count"), type="integer", default=5, help="Number of random normals to generate [default %default]", metavar="number"),
  make_option("--mean", default=0, help="Mean if generator == \"rnorm\" [default %default]"), 
  make_option("--sd", default=1, metavar="standard deviation", help="Standard deviation if generator == \"rnorm\" [default %default]"), 
  make_option("--y", action = "store_true", default = FALSE, help = "If this boolean flag is activated var is set to true")
)

opt <- parse_args(OptionParser(option_list=option_list))

# access the command line arguments with this list
opt
```

On the command line, run the script using

```{r, eval = FALSE}
R CMD BATCH '--args -c=4 --mean=4' in_file.R out_file.out
Rscript in_file.R -c=4 --mean=4
```

Obtain the list of arguments like so

```{r, eval = FALSE}
Rscript in_file.R -h
```

It is useful for the script to print out the incoming arguments so that one can check later on. 

**Outputs**

R can send commands to the commandline with the function

```{r, eval = FALSE}
system(cmd)
```

There are additional options to run the command, such as running the command in the background, saving responses from command line, etc.

[apply_post]: http://jnguyen92.github.io/nhuyhoa//2015/10/Apply-Parallel-Processing.html
