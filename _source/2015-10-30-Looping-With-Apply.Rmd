---
layout: post
title: "Looping Through Apply (R)"
date: "October 30, 2015"
categories: ['r programming']
---

* TOC
{:toc}

```{r, echo = FALSE, warning = FALSE}
library(jn.general)
lib(data, viz)
```


For loops in R are can be quite slow as the number of iterations increase. Apply functions or parallel processing are recommended to optimize code for looping operations. 

# Apply as a For Loop Replacement
Lapply can replace for-loops when each iteration is independent of the others. 

Recall the basic setup of the for loop: 
{% highlight r%}
for (LOOP_VAR in SEQUENCE) {
  EXECUTION
  # more control
  break
  next
}
{% endhighlight%}

The setup is similar when using lapply.
{% highlight r%}
lapply(SEQUENCE, function(i, ...){
  EXECUTION
  return(OBJ)
}, 
# additional arguments for the function
...)
{% endhighlight%}

Note that the keywords break and next cannot be used with `lapply()`. In order to skip an iteration, implement a conditional statment and return an empty object. 

The output of an `lapply()` is a list object. 

![lapply diagram](http://jnguyen92.github.io/nhuyhoa/figure/images/lapply_diagram.png)

# plyr Functions
The package plyr has a number of apply functions to that allow for proper control of input and outputs types. 

Plyr functions have the form `__ply()`. 

input/output | list | data.frame | array | empty
-------------|------|------------|-------|------
**list**     | llply| ldply      | laply | l_ply
**data.frame**| dlply| ddply     | daply | d_ply
**array**    | alply| adply      | aaply | a_ply

<p></p>
The first character (`l`, `d`, `a`) denotes the format of the incoming object. The second character (`l`, `d`, `a`, `_`) denotes the format of the outcoming object. 

The function `llply()` 

* takes in a list
* applies a function on all elements of that list
* returns the results in a list

The function `ldply()` 

* takes in a list
* applies a function on all elements of that list
* merges the results into a data frame

The `_` refers to no output. This is useful for when the outputs are taken care of (saved or printed) within the loop, and there is no need for other output.

In addition to providing control for input and output types, plyr functions have additional arguments for increased efficiency. 

* `.progress`: allows for the creation of a progress bar to inform users of the looping progress. Use `.progress = "time"` to get constant updates on how much longer code is expected to run
* `.parallel` and `.paropts`:  allows iterations to be run in parallel. Details on how to do this is provided in a later section.

## l*ply
The function `l*ply(.data, .fun, ...)` is probably the most general. It is identical to the `lapply()` function.

## d*ply
The function `d*ply()` are used with data frames. However, other packages provide better control and support for these tasks. See the post on [Split-Apply-Combine][sac_link]{:target="blank"} for more information.

## a*ply
The function `a*ply(.data, .margins, .fun, ...)` will apply a functions on the rows and/or columns of an array. The rows or columns can be specified using the `.margins`, pass 1 to split by rows, 2 to split by columns. 

```{r}
# generate random data
set.seed(1)
x <- raply(4, sample(1:4, 6, replace = TRUE))
x
# count the # of even values in each col
y <- alply(x, 2, function(x) sum(x %% 2 == 0))
y %>% unlist 
```
Here the first row is the column name, the second row is the count of even values

Note that data frames of one type are technically arrays too. So they can be passed as the `.data` argument to `a*ply()`.

## r*ply
The function `r*ply(.n, .expr, ...)` replicates an expression/function n times. This is useful for running multiple iterations of random number generator.


```{r, eval = FALSE}
# 5 replicates of uniform random data of size 3
rdply(5, runif(3))
```

<div class = "dftab">
```{r, echo = FALSE}
rdply(5, runif(3)) %>% nhuyhoa_df_print()
```
</div>

# Multivariate Apply
`Map` can simultaneously loop over several vectors at once. 

For example, it can be used to compute multiple weighted means of two different data sets. Here, one set of weights  is applied to two different data sets. 
```{r}
# list of obs and weights
obs <- replicate(5, runif(10), simplify = FALSE)
weights <- replicate(5, rpois(10, 5) + 1, simplify = FALSE)

# multivariate apply
Map(function(x, w) weighted.mean(x, w, na.rm = TRUE), obs, weights) 
```
# Purrr Functions

The library `purrr` simplifies the apply functions. 

The function `map()` takes a list/vector, applies a function and returns a list. There are alternatives that specifies the return object, such as `map_lgl()`, `map_int()`, `map_dbl()`, `map_chr()`, `map_df()`, etc. Functions can be listed using `function()` or as a formula. 

```{r, eval = FALSE}
map(list, function, ...)
```
There are also multivariate options, such as `map2()`, `pmap()`. These options also have alternative that specifies the return object.

```{r, eval = FALSE}
map2(1:3, 3:1, ~ .x * .y)
pmap(list(4:6, 1:3, 10:8, 7:9), c)
```
Functions can be specified as a formula that starts with `~`, the variables `.x` and `.y` refers to the first and second incoming argument. 

The map functions also provides filtering options with `map_if()` and `map_at()`.

```{r, eval = FALSE}
map_if(list, condition, function)
map_at(list, locations, function)
```
The package also allows for applying a list of functions to an object. To do this use the functions `invoke()`, `invoke_map()`, etc.

```{r, eval = FALSE}
invoke_map(list(runif, rnorm), list(n = 10))
```
There are also functions that can be used to filter a vector: `keep()` and `discard()`.

```{r, eval = FALSE}
keep(1:10, ~ . %% 2 == 0)
discard(1:10, ~ . %% 2 == 0)
```

The package has a number of good functions for working in R, including

* `reduce()` and `reduce_right()` iteratively applies a binary function to list elements
* `accumulate()` and `accumulate_right()` does the same as the above functions but keeps intermediary results
* `transpose()` which restructures a list similar to `jn.general::extract_list()` explained below
* `safely()`, `quietly()`, and `possibly()` for working with errors

# Cool Uses of Apply

## Example 1
Rather than opening a large number of files one by one, an apply loop can be used to open all the files at once.

{% highlight r %}
# given a directory
directory <- "~/Desktop/file_monster/"

# get a list of all the files in the directory
file_paths <- list.files(directory, full.names = TRUE)

# we only want to open the csv files
file_paths <- file_paths %>% str_subset(".csv")

# open all of our csv files using data.table::fread
files <- llply(file_paths, data.table::fread, .progress = "time")

# if all the files are of the same format, combine them into one file
super_set <- rbindlist(files)
{% endhighlight %}

The object `super_set` will have all the specified files in one compact list. The advantage of the apply functions is that it isn't restricted to simple functions. So if there are additional data pre-processing steps, user-defined functions can also be used with the apply functions.

## Example 2

Imagine a work flow where independent models are constructed with different parameters. The goal is to group common data outputs from each of those models for a more simplified analysis. For example, multiple models can be compared by gathering all diagnostics into one data.frame. An easy way to do this is with the function `jn.general::extract_list()`, which uses a recursive apply/looping function to accumulate the data structures. (There is a similar function `purrr::transpose()`).

Here's an example of when `jn.general::extract_list()` would come in handy.
```{r}
# function to generate some random data
random_data <- function(){
  x <- list(
    temp = list(
      hot = list(red = data.frame(i = sample(c("M", "T", "W", "Th", "F"), 3)), 
                 orange = data.frame(j = sample(month.name, 2))),
      cold = data.frame(x = runif(7, 0, 25), y = sample(state.name, 7))
    ),
    CA = matrix(sample(-10:9, 16), nrow = 4),
    WA = sample(LETTERS, 5)
  )
  return(x)
}

# look at our outputs
output <- llply(1:3, function(i) random_data())
output[[1]]
output[[2]]
```
And so on for the following iterations.

So this is the result of the model builds. It isn't very useful broken up into so many pieces, so let's use `jn.general::extract_list()` on the output. 
``` {r}
# rename the data frames
renamed <- rename_list(output, names = paste0("m", 1:length(output)))
# extract data
extract <- extract_list(renamed)
extract
```

The function returns clean aggregated outputs, making analysis and comparison much more simple!

The separate files can be extracted quite simply with `$`. 
```{r}
# template for extraction
random_letters <- extract$WA
cold_states <- extract$temp$cold
```


[sac_link]: http://jnguyen92.github.io/nhuyhoa//2015/10/Split-Apply-Combine.html
