---
layout: post
title: "Apply and Parallel Processing (R)"
date: "October 30, 2015"
categories: ['r programming']
---

* TOC
{:toc}

```{r, echo = FALSE, warning = FALSE}
library(jn.general)
lib(data, viz)
```

For loops in R are known to be quite slow as the number of iterations increase. Thus it is advised to use apply functions for looping operations. In cases when it is desirable to optimize code even more, parallel processing can be used alongside the apply functions.

# Apply as a For Loop Replacement
Lapply is a desireable replacement of for-loops when each iteration is independent of the others. 

Recall the basic setup of the for loop: 
{% highlight r%}
for (LOOP_VAR in SEQUENCE) {
  EXECUTION
  # more control
  break
  next
}
{% endhighlight%}

The setup is similar when using apply.
{% highlight r%}
lapply(SEQUENCE, function(i, ...){
  EXECUTION
  return(OBJ)
}, 
# additional arguments for the function
...)
{% endhighlight%}

Note that the keywords break and next cannot be used with `lapply()`. In order to skip an iteration, enact a conditional statment and return an empty object. 

The output of an `lapply()` is a list object. 

![lapply diagram](http://jnguyen92.github.io/nhuyhoa/figure/images/lapply_diagram.png)

# plyr Functions
The package plyr has a number of apply functions to that allow for proper control of input and outputs types. 

Plyr functions have the form `__ply()`. 

```{r, echo = FALSE}
title <- c("list", "data.frame", "array", "empty")
list <- c("llply", "ldply", "laply", "l_ply")
data.frame <- c("dlply", "ddply", "daply", "d_ply")
array <- c("alply", "adply", "aaply", "a_ply")
x <- rbind(title, list, data.frame, array) %>% data.frame 
colnames(x) <- x[1,] %>% unlist
x <- x[2:nrow(x),]
x[,'input\\output'] <- rownames(x)
rownames(x) <- NULL
x %>% dplyr::select(one_of("input\\output"), everything()) %>% kable
```

<p></p>
The first character (`l`, `d`, `a`) denotes the format of the incoming object. The second character (`l`, `d`, `a`, `_`) denotes the format of the outcoming object. 

For example, `llply()` means take a list, apply a function on all elements of that list, and the results in a list. On the other hand, `ldply()` means take a list, apply a function on all elements of that list, and merge the results into a data frame.

The `_` refers to no output. This is useful for when the outputs are taken care of (saved or printed) within the loop, and you have no need for overall outputs.

In addition to providing control for input and output types, plyr functions have additional arguments for increased efficiency. 

* `.progress`: allows for the creation of a progress bar to inform users of the looping progress. Use `.progress = "time"` to get constant updates on how much longer code is expected to run
* `.parallel` and `.paropts`:  allows iterations to be run in parallel. Details on how to do this is provided in a later section.

## l*ply
The function `l*ply(.data, .fun, ...)` is probably the most general. It is identical to the `lapply()` function provided in the first section.

## d*ply
The function `d*ply()` are used with data frames. However, more recent packages provide better control and support for these tasks. See the post on [Split-Apply-Combine][sac_link]{:target="blank"} for more information.

## a*ply
The function `a*ply(.data, .margins, .fun, ...)` will apply a functions on the rows and/or columns of an array. The rows or columns can be specified using the `.margins`, pass 1 to split by rows, 2 to split by columns. 

```{r}
# generate random data
set.seed(1)
x <- raply(4, sample(1:4, 6, replace = TRUE))
x
# count the # of even values in each col
y <- alply(x, 2, function(x) sum(x %% 2 == 0))
y %>% unlist 
```
Here the first row is the column name, the second row is the count of even values

Note that data frames of one type are technically arrays too. So they can be passed as the .data argument to `a*ply()`.

## r*ply
The function `r*ply(.n, .expr, ...)` replicates an expression/function n times. This is great for running multiple iterations of random number generator.


```{r, eval = FALSE}
# 5 replicates of uniform random data of size 3
rdply(5, runif(3))
```

<div class = "dftab">
```{r, echo = FALSE}
rdply(5, runif(3)) %>% nhuyhoa_df_print()
```
</div>

# Multivariate Apply
We can simultaneously loop over several vectors at once with `Map`.

For example, we can compute multiple weighted means with two list, one with multiple vectors of observations and one with corresponding weights.
```{r}
# list of obs and weights
obs <- replicate(5, runif(10), simplify = FALSE)
weights <- replicate(5, rpois(10, 5) + 1, simplify = FALSE)

# multivariate apply
Map(function(x, w) weighted.mean(x, w, na.rm = TRUE), obs, weights) 
```

# Foreach Functions
Under Construction :)

# Parallel Processing
Parallel processing allows independent tasks to be dispatched to different cores. These cores compute them in parallel and combine the results. Running tasks in parallel can reduce the runtime in half or more! However parallel processing is only recommended for time-consuming tasks. With shorter tasks, it may take more time to set up the cores than to run the analysis iteratively!

Here's the general setup:
{% highlight r %}
# load library
library(doParallel)

# find out max # cores you can use
detectCores()

# generate clusters - n = # of clusters
cl <- makeCluster(n)
registerDoParallel(cl)

# use plyr to run in parallel
llply(.data, .fun, ...,
      .parallel = TRUE, 
      .paropts = list(.packages = c("dplyr", "magrittr"))
      )

# close clusters
stopCluster(cl)
{% endhighlight %}

Think of each core as its own separate "R session", in that it will only have information passed to it from the function. The cores will not have access to variables and packages that have been loaded in the current environment. Thus it is best to provide the function with all necessary objects (as parameters) and provide all necessary packages in the `.paropts` argument. 

Note that this is one of many ways to run parallel processing. 

# Cool Uses of Apply

## Example 1
Say we have a number of files that we want to open. Rather than reading them in one by one, we could use an apply loop.

{% highlight r %}
# given a directory
directory <- "~/Desktop/file_monster/"

# get a list of all the files in the directory
file_paths <- list.files(directory)

# we only want to open the csv files
file_paths <- file_paths %>% str_subset(".csv")

# open all of our csv files using data.table::fread
files <- llply(file_paths, data.table::fread, .progress = "time")

# if all the files are of the same format, combine them into one file
super_set <- rbindlist(files)
{% endhighlight %}

And there you have it, all the files you need in one compact list. The great thing about `llply()` is that you aren't restricted to simple functions. So instead of just reading in the file, you could do even more data processing to fit your needs. The sky's the limit!

## Example 2
In some cases, we want to build any number of independent models and group common data outputs for simple extraction. So perhaps we want all the diagnostics in one data frame so we can compare them across multiple models. An easy way to do this is with the function `extract_list()`, which uses a recursive looping function to accumulate the data structures. 

Here's an example of when `extract_list()` would come in handy.
```{r}
# function to generate some random data
random_data <- function(){
  x <- list(
    temp = list(
      hot = list(red = data.frame(i = sample(c("M", "T", "W", "Th", "F"), 3)), 
                 orange = data.frame(j = sample(month.name, 2))),
      cold = data.frame(x = runif(7, 0, 25), y = sample(state.name, 7))
    ),
    CA = matrix(sample(-10:9, 16), nrow = 4),
    WA = sample(LETTERS, 5)
  )
  return(x)
}

# look at our outputs
output <- llply(1:3, function(i) random_data())
output[[1]]
output[[2]]
```
And so on for the following iterations.

So this is the result of our model builds. It isn't very useful broken up into so many pieces, so let's use `extract_list()` on our output. 
``` {r}
# rename the data frames
renamed <- rename_list(output, names = paste0("m", 1:length(output)))
# extract data
extract <- extract_list(renamed)
extract
```

Clean aggregated outputs, makes analysis and comparison much more simple!

The separate files can be extracted quite simply with `$`. 
```{r}
# template for extraction
random_letters <- extract$WA
cold_states <- extract$temp$cold
```


[sac_link]: http://jnguyen92.github.io/nhuyhoa//2015/10/Split_Apply-Combine.html
