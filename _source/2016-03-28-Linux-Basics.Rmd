---
layout: post
title: "Linux Basics"
date: "March 28, 2016"
categories: ['basics']
---

* TOC
{:toc}

**Cheatsheet:**

See [Linux Cheatsheet][linux_ref]{:target = "_blank"}

# Generic Commands

* `alias x='cmd'; x` to save a series of commands under a different name
* `|` to chain commands
* `xargs` reads items from standard input delimited by blanks and executes command multiple times
* `>` or `>>` divert all output to a file
* `&>` or `&>>` diverts outputs & errors to a file

```{r, eval = FALSE}
# example: delete all *.txt files
find . -name *.txt | xargs rm

# example: package all *.jpg files 
find . -name *.jpg | xargs tar -zcf jpg.tar.gz

# example: batch rename
ls | grep \.jpg$ | sed 'p;s/\.jpg/\.png/' | xargs -n2 mv
```

* `echo` repeat text, can pipe into files
* `date` to obtain the date and time

# Working With Files

## Editing Files

* `grep` for pattern matching
  * `grep -c` counts matches
  * `grep -i` ignores case
  * `grep -e` expanded regular expression 
  * `grep -v` opposite of the match
  * `grep pattern --color=auto` highlight the match
  * special characters: `^`, `$`, `*`
* `tr 'abc' 'ABC'` translate lower case to upper case
  * `tr a b < file` translate a to b in the file
  * `tr -d 'aeiou'` delete specific characters
* `uniq` for unique values
* `wc -l` word counts, counts each line
* `paste` merges lines of files together
* `join` merges tables of files together by a given column
* `diff` compare files line by line

* `sort` sorting
```{r, eval = FALSE}
# sort by 1st col, then 2nd, then 3rd ...
sort input.txt

# sort 2nd col as numbers, descending order; then sort 3rd col as strings ascending order
sort -k2,2nr -k3,3 input.txt
```

* `cut` cuts out selected portions of each line from each file and writes to standard output
```{r, eval = FALSE}
# cut 1, 2, 3, 5, 7 columns
cut -f1-3,5,7- input.txt

# cut 3rd column w/ columns separated by a single space
cut -d" " -f 3 input.txt
```

**Example**
```{r, eval = FALSE}
# find the 10 most common words
cat temp.txt | tr "[A-Z]" "[a-z]" | tr -c "[:alnum:]" "[\n*]" | sort | uniq -c | sort -nr | head -10
```

## Finding Files
```{r, eval = FALSE}
find . -name *sample*
```

## Zipping Files

Some common action terms

`tar` options:

* `c` create an archive
* `t` list the contents of an archive
* `x` extract 
* `v` verbose mode
* `z` process through gzip
* `f` specify name of the $$.tar$$ files to create

```{r, eval = FALSE}
# creating a tar file
tar -cvf file_name.tar file1 file2 ... filen

# create a gzip file
tar -czvf file_name.tar.gz file1 file2 ... filen

# unpack tar files
tar -xvf file_name.tar

# unpack tar.gz files
tar -xzvf file_name.tar.gz
```

`zip` options:

```{r, eval = FALSE}
# zip files
zip file_name file1 file2 ... filen

# unzip files
unzip file_name.zip
```

`gzip` options:

```{r, eval = FALSE}
# gzip files
gzip file_name file1 file2 ... filen

# unzip files
gunzip file_name.zip
```
View zipped files
```
zcat file_name
```

## Changing Permissions of Files

Syntax: `chmod (user)(+-=)(rwx) (filename)`

Options for users: 

* `u` user (file owner)
* `g` group
* `o` others/world
* `a` all (if no characters given, all is assumed)

The `+-=` refers to assigning and removing permissions

File access options: 

* `r` read and open
* `w` write
* `e` executable

When listed via `ls`, the file access options from left to right are for owner, group, all. 

```{r, eval = FALSE}
# make file readable by group
chmod g+r filepath

# make file executable by all
chmod +x filepath
```

## Printing Files

```{r, eval = FALSE}
# obtain a list of available printers
lpstat -p -d

# print queue
lpq -P printer_name

# print file
lpr -P printer_name filename

# pass commands to printer: print two sides
lpr -o sides=two-sided-long-edge -Pprinter_name file_name
```

# My Computer and Other Servers 

**Log In Via ssh:**

```{r, eval = FALSE}
ssh username@place
```
See [this link][ssh_login]{:target = "_blank"} to learn how to set up a ssh login without a password.

**Download from a Web Server:**
```{r, eval = FALSE}
curl -o online_file_name
wget --no-check-certificate -q -O output_name website
```

**Download/Upload to a Server:**

```{r, eval = FALSE}
# using rsync
rsync -a filename username@place:file_directory

# using scp 
scp original.file user@location.to.transfer:file_path

# using scp with directories
scp -rp file location.to.transfer
```

**Run on Background in Server:**

```{r, eval = FALSE}
# add an & at the end of command
sh filename.sh >> output.txt 2> err.txt &
sh filename.sh &>> console.txt &

# check on currently running background commands; for current user
top
top u username

# push to background after starting
sh filename.sh >> output.txt
# do cntrl + z
bg

# run regularly in background: crontab, check online for documentation of how to run regularly
crontab -e
# edit crontab file with commands to use
crontab -l

# run regularly in background: watch
watch -n secs cmd
```

**Communicate Results via Email**

```{r, eval = FALSE}
echo script | mail -s "subject line" email_address
```

# Shell Scripting

## Variables

**Setting Variables:**

```{r, eval = FALSE}
# set variable, note no spaces
VAR="value"
VAR2=25
VAR3=$(echo ${statement} | sed 's/\(<\/*[a-z0-9]*>\)[A-Za-z0-9\t ]*/\1/g')

# array variables
declare -a NAME
NAME=(val2 val2 ... valN)
NAME[index]=value

# set environmental vars so child processes can inherit
export VAR2="value2"
```

**Call Variables:**

```{r, eval = FALSE}
# call a variable (brackets are not required but convention)
cmd ${VAR}

# call arrays (should include [], otherwise only prints first element)
cmd ${NAME[0]}
cmd ${NAME[@]}

# find the length of a variable
cmd ${#VAR[@]}

```

**Substitution Operators:**

If the variable is not set:

```{r, eval = FALSE}
# return another value
echo "${TMP:-value}"

# return another value and set to value
echo "${TMP:=value}"

# abort
echo "${TMP:?value}"
```

Obtaining substrings
```{r, eval = FALSE}
# obtain everything after 4th char
echo ${STR:4}

# start at 6th char and obtain a string fo length 5
echo ${STR:6:5}

# obtain portion of string that isn't name
echo ${STR%name}
```

## Doing Math
```{r, eval = FALSE}
# using double parenthesis
a=$((4 + 5))
c=$(($a + 2))
((a++))
((a+=4))
echo $((5+3))
```


## Conditions

```{r, eval = FALSE}
# returns 0 for true; 1 for false

# test for equality with strings
[ 'hi' = 'hello' ]; echo $?

# test for equality with numbers
[ 1 -eq 1 ]; echo $?
[ 1 -ne 1 ]; echo $?
[ 1 -lt 1 ]; echo $?
[ 1 -le 1 ]; echo $?
[ 1 -gt 1 ]; echo $?
[ 1 -ge 1 ]; echo $?

# test multiple commands
[ 'hi' != 'hello' ] && test [ 'hi' = 'hi' ]; echo $?
[ ${var} = 'hello' ] || test[ 'hi' = 'hi' ]; echo $?

# check empty argument: empty (z) and not empty (n)
[ -z "" ]; echo $?
[ -n "" ]; echo $?

# test for existence (e) or non-emptiness (s)
[ -e file.txt ]; echo $?
[ -s file.txt ]; echo $?

# test permissions: readable (r), writable (w), executable (x)
[ -r file.txt ]; echo $?
[ -w file.txt ]; echo $?
[ -x file.txt ]; echo $?

# test lifetime of files: newer (nt) and older (ot)
[ oldfile.txt -nt newfile.txt ]; echo $?
[ oldfile.txt -ot newfile.txt ]; echo $?
```

# Sed

Sed is a command line tool to conduct regular expressions commands.

**Search and Replace Text:**

`(address)s/(search)/(replacement)/(modifier)`

* Addresses are specified: `start, end`
* Both search and replacement are strings
* Modifiers: 
  * `g`: global, replace for all occurances on the line
  * `p`: print only the lines where replacement occurs
  * `w`: write to a file

```{r, eval = FALSE}
# example: addresses
sed '1,2s/heart/love/' test.txt

# example: global modifier
echo "hi, hi, hi" | sed 's/hi/hello/'
echo "hi, hi, hi" | sed 's/hi/hello/g'

# bad example: print modifier - doesn't work
sed 's/heart/love/p' test.txt

# example: different print modifier, prints original and edit
sed 'p;s/heart/love/' test.txt

# example: print out lines by number; -n suppresses printing of other lines
sed -n '2,5p' test.txt

# example: regex and backreferences
sed 's/\([1-9]*\) \(#\)/ \2 \1/' test.txt

# example: & as the matched string
sed 's/^[AEIOU][a-z]*/\*&\*/' test.txt

# example: write results out
sed 's/^[AEIOU][a-z]*/\*&\*/w output.txt' test.txt

# example: trim lead & trailing whitespaces
sed 's/^[ \t]*//;s/[ \t]*$//' test.txt

# example: delete blank lines
sed '/^$/d' test.txt
```

* Edit the document in place using sed
```{r, eval = FALSE}
sed -i 's/old/new/' test.txt
```

* Apply a sequence of commands using a sed script
```{r, eval = FALSE}
# sed script
s/blue/black/g
s/windows/mac/g
s/square/circle/g

# call script
sed -f sed_script test.txt
```

# Awk
Awk is a scripting language used for text extraction and processing. 

```{r, eval = FALSE}
# form strings
ls -l | awk '{print "my username is " $3}'

# choose rows where col 3 larger than col 5
awk '$3>$5' input.txt > output.txt

# extract col 2, 4, 5, last col - 1, last col
awk '{print $2, $4, $5, $(NF-1), $NF}' input.txt

# import simple csv
awk -F , '{print $1, $2}'

# import tab delimited
awk -F '\t' '{print $1, $2}'

# export from a tab-separated file (OFS = output field separator)
awk 'BEGIN{OFS="\t"}{print $2, $4, $5}' input.txt

# show rows between 20th and 80th rows (NR = row number)
awk 'NR>=20&&NR<=80' input.txt

# awk filter 2nd column that equals variable $t
awk -v var=$t '($2==var){print}'
```

Additional operations:

```{r, eval = FALSE}
# print sum of col 2
awk '{x+=$2}END{print x}' input.txt

# calculate average of 2nd col
awk '{x+=$2}END{print x/NR}' input.txt

# print each line in 7th col that matches regular expression
awk '$7 ~ /^[a-f]/' input.txt

# print lines that do not match
awk '$7 !~ /^[a-f]/' input.txt

# calculate sum of col 2 & 3; put it at end of row or replace 1st col
awk '{print $0,$2+$3}' input.txt
awk '{$1=$2+$3;print}' input.txt

# join two files on col 1
awk 'BEGIN{while((getline<"file1.txt")>0)l[$1]=$0}$1 in l{print $0"\t"l[$1]}' file2.txt > output.txt

# count number of occurrence of column 2 (uniq -c):
awk '{l[$2]++}END{for (x in l) print x,l[x]}' input.txt

# apply "uniq" on column 2, only printing the first occurrence (uniq):
awk '!($2 in l){print;l[$2]=1}' input.txt

# count different words
awk '{for(i=1;i!=NF;++i)c[$i]++}END{for (x in c) print x,c[x]}' input.txt

# match multiple values on col 2
POSes="1 2 3"
awk -v POSes="$POSes" 'BEGIN{ split(POSes,tmp); for (i in tmp) poses[tmp[i]] } $2 in poses{ print $0 }' input.txt
```


**Format of .awk File:**

```{r, eval = FALSE}
BEGIN{
  // initialize variables: executes only once
}
{
  /pattern/ {action}
  // runs every input line that matches optional pattern
}
END{
  // cleanup: executed once after file is exhausted
}
```

```{r, eval = FALSE}
# example
BEGIN{
  printf "Just getting started\n";
  n = 0;
}

{
  print ${0} // prints the line
  if(4 == 4) {++n} // increment n 
}

END{
  printf "We are at the end:" n; 
}

# run awk script
awk -f awk_script.awk test.txt
```

[linux_ref]: https://drive.google.com/file/d/0B5VF_idvHAmMeXJRRWdFTFQzMEU/view?usp=sharing
[ssh_login]: http://www.linuxproblem.org/art_9.html
