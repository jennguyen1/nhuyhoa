---
title: "To Be or Not To Be: Subsetting"
layout: post
categories: r data_wrangling
---

* TOC
{:toc}

```{r global_opts, echo = FALSE}
library(jn.general)
lib(viz)
```

# Subsetting Functions in R

In a previous post, I dicussed the subsetting functions available via the dplyr package, including the `filter()`, `slice()`, and `select()` functions. There are a number of additional ways to subset data frames in R. 

However what if rather than tossing the data that does not correspond to the subset (call it the "anti-subset"), we wanted to keep it? Say perhaps, we want to subset, perform a sequence of operations, and then somehow relate the two to each other. One could easily subset two times, once with the condition and again with the negation. However in some cases, obtaining the anti-subset isn't all that straight forward. For example what if the subset was obtained randomly, as with functions like `sample_n()` or `sample_frac()`, or when there is no clear negation, such as `view_duplicated()`?

Having faced this issue many times, I wrote the `to_be()` function as a way to obtain both the subsetted data and the "anti-subset". It is available in the [jn.general package][package_link]{:target="blank"}.

# To Be or Not To Be

The function`to_be()` is quite simple when broken down. It takes in a data frame, a subsetting function, and any additional arguments needed for the subset. After performing the needed operations, `to_be()` returns a list of two objects. The first object returned, "to_be", is the resulting data frame when the subset function is applied to the input data. The second object returned, "not_to_be" is the anti-subset, obtained by considering a total of three cases: subset by rows, subset by columns, and subset by rows and columns. 

## Subset by Rows

```{r subset by rows ex}
by_row <- to_be(mtcars, dplyr::filter, cyl != 4, mpg > 20)
```

{% highlight r %}
# data corresponding to cars where the cyl is not 4 and mpg is greater than 20
by_row[["to_be"]]
{% endhighlight %}
<div class = "dftab">
```{r, echo = FALSE}
by_row[["to_be"]] %>% kable(format = "html")
```
</div><p></p>

{% highlight r %}
# data corresponding to cars where cyl is 4 or mpg is less than 20
by_row[["not_to_be"]] %>% head
{% endhighlight %}
<div class = "dftab">
```{r, echo = FALSE}
by_row[["not_to_be"]] %>% nhuyhoa_df_print()
```
</div>

## Subset by Columns

```{r subset by col ex}
by_col <- to_be(mtcars, dplyr::select, -one_of(c("gear", "vs")))
```


{% highlight r %}
# data corresponding to all car information except gear & vs 
by_col[["to_be"]] %>% head
{% endhighlight %}
<div class = "dftab">
```{r, echo = FALSE}
by_col[["to_be"]] %>% nhuyhoa_df_print()
```
</div><p></p>

{% highlight r %}
# data corresponding to gear and vs information of cars
by_col[["not_to_be"]] %>% head
{% endhighlight %}
<div class = "dftab">
```{r, echo = FALSE}
by_col[["not_to_be"]] %>% nhuyhoa_df_print()
```
</div>


## Subset by Rows and Columns

```{r subset by both ex}
by_both <- to_be(mtcars, subset, subset = mpg > 20, select = c(cyl, hp, wt))
```

When the function both subsets rows and selects columns, the anti-subset data frame will replace the extracted values with NAs. 

{% highlight r %}
# data corresponding to cyl, hp, wt of cars with an mpg greater than 20
by_both[["to_be"]]
{% endhighlight %}
<div class = "dftab">
```{r, echo = FALSE}
by_both[["to_be"]] %>% kable(format = "html")
```
</div><p></p>

{% highlight r %}
# data corresponding to cyl, hp, wt of cars with an mpg greater than 20 are replaced with NAs
by_both[["not_to_be"]] %>% head(10)
{% endhighlight %}
<div class = "dftab">
```{r, echo = FALSE}
by_both[["not_to_be"]] %>% head(10) %>% kable(format = "html")
```
</div>

# Challenge Round
Letâ€™s do something a little more challenging to see to_be in action. With this data set, we want to remove the duplicated id entries by hand and merge them back into the non-duplicates. 

<div class = "dftab">
```{r challenge data, echo = FALSE}
set.seed(1)
data <- rdata(10,
  gen_seq(1, 10, name = "id"),
  gen_age(),
  gen_gender(),
  gen_race(),
  gen_state(),
  .id = FALSE
) %>% arrange(id)

data %>% kable(format = "html")
```
</div><p></p>

```{r find duplicates}
result <- to_be(data, view_duplicated, id)
```

The duplicated id entries:

{% highlight r %}
result[["to_be"]]
{% endhighlight %}
<div class = "dftab">
```{r to be, echo = FALSE}
x <- result[["to_be"]]
rownames(x) <- NULL
x %>% kable(format = "html")
```
</div><p></p>

The non-duplicated id entries:

{% highlight r %}
result[["not_to_be"]]
{% endhighlight %}
<div class = "dftab">
```{r not to be, echo = FALSE}
y <- result[["not_to_be"]] 
rownames(y) <- NULL
y %>% kable(format = "html")
```
</div><p></p>

From the duplicated id's, I'll keep the id that corresponds to a female or, if none of the duplicated entries are female, an id corresponding to someone greater than 50 years old. 

{% highlight r %}
result[["to_be"]] %>% group_by(id) %>% arrange(gender, desc(age)) %>% slice(1)
{% endhighlight %}
<div class = "dftab">
```{r, echo = FALSE}
z <- x %>% group_by(id) %>% arrange(gender, desc(age)) %>% slice(1) 
z %>% kable(format = "html")
```
</div><p></p>

Now combine the results back together.

{% highlight r %}
# obtain the duplicated entries
result[["to_be"]] %>% 
  # group by unique id's
  group_by(id) %>% 
  # order by gender (females first) and decreasing age
  arrange(gender, desc(age)) %>% 
  # take the first entry in each group
  slice(1) %>% 
  # combine results with non-duplicated data
  rbind(result[["not_to_be"]])
{% endhighlight %}
<div class = "dftab">
```{r, echo = FALSE}
a <- result[["to_be"]] %>% group_by(id) %>% arrange(gender, desc(age)) %>% slice(1) %>% rbind(result[["not_to_be"]]) %>% arrange(id)
rownames(a) <- NULL
a %>% kable(format = "html")
```
</div>

[package_link]: https://github.com/jnguyen92/jn.general
