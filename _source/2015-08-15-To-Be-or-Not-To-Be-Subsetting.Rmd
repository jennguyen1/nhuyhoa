---
title: "To Be or Not To Be: Subsetting (R)"
layout: post
categories: ['r programming']
---

* TOC
{:toc}

```{r global_opts, echo = FALSE}
library(jn.general)
lib(viz)
```

# Subsetting Functions in R

There are a number of different subsetting functions available in base R and external packages. 

However, there are no functions available for keeping (rather than discarding) the data that does not correspond to the subset (call it the "anti-subset"). This process might be useful for performing a different set of operations on two different subsets of the data and combining the results back again. 

In some cases, obtaining the anti-subset isn't straightforward. For example, when the subset is obtained randomly (as with `sample_n()` or `sample_frac()`) or when there is no clear negation (as with `jn.general::view_duplicated()`). 

A simple solution is to use the function `jn.general::to_be()`, which returns both the subsetted and the anti-subsetted data. It is available in the [jn.general package][package_link]{:target="blank"}.

# To Be or Not To Be

The function `to_be()` is quite simple when broken down. 

The parameters include

* A data.frame
* A subsetting function
* Any additional arguments to be passed to the subset function

After performing the subset operations, `to_be()` returns a list of two objects

* A data.frame "to_be": the resulting data.frame when the subset function is applied to the input data
* A data.frame "not_to_be": the anti-subset, the opposite of the subset operation

## Subset by Rows

```{r subset by rows ex}
by_row <- to_be(mtcars, dplyr::filter, cyl != 4, mpg > 20)
```

{% highlight r %}
# data corresponding to cars where the cyl is not 4 and mpg is greater than 20
by_row[["to_be"]]
{% endhighlight %}
<div class = "dftab">
```{r, echo = FALSE}
by_row[["to_be"]] %>% kable(format = "html")
```
</div><p></p>

{% highlight r %}
# data corresponding to cars where cyl is 4 or mpg is less than 20
by_row[["not_to_be"]] %>% head
{% endhighlight %}
<div class = "dftab">
```{r, echo = FALSE}
by_row[["not_to_be"]] %>% nhuyhoa_df_print()
```
</div>

## Subset by Columns

```{r subset by col ex}
by_col <- to_be(mtcars, dplyr::select, -one_of(c("gear", "vs")))
```

{% highlight r %}
# data corresponding to all car information except gear & vs 
by_col[["to_be"]] %>% head
{% endhighlight %}
<div class = "dftab">
```{r, echo = FALSE}
by_col[["to_be"]] %>% nhuyhoa_df_print()
```
</div><p></p>

{% highlight r %}
# data corresponding to gear and vs information of cars
by_col[["not_to_be"]] %>% head
{% endhighlight %}
<div class = "dftab">
```{r, echo = FALSE}
by_col[["not_to_be"]] %>% nhuyhoa_df_print()
```
</div>


## Subset by Rows and Columns

```{r subset by both ex}
by_both <- to_be(mtcars, subset, subset = mpg > 20, select = c(cyl, hp, wt))
```

When the function both subsets rows and selects columns, the anti-subset data frame will replace the extracted values with NAs. 

{% highlight r %}
# data corresponding to cyl, hp, wt of cars with an mpg greater than 20
by_both[["to_be"]]
{% endhighlight %}
<div class = "dftab">
```{r, echo = FALSE}
by_both[["to_be"]] %>% kable(format = "html")
```
</div><p></p>

{% highlight r %}
# data corresponding to cyl, hp, wt of cars with an mpg greater than 20 are replaced with NAs
by_both[["not_to_be"]] %>% head(10)
{% endhighlight %}
<div class = "dftab">
```{r, echo = FALSE}
by_both[["not_to_be"]] %>% head(10) %>% kable(format = "html")
```
</div>

# Challenge Round
Let's do something a little more challenging to see `to_be` in action. With this data set, remove the duplicated id entries by hand and merge them back into the non-duplicates. 

<div class = "dftab">
```{r challenge data, echo = FALSE}
set.seed(1)
data <- rdata(10,
  gen_seq(1, 10, name = "id"),
  gen_age(),
  gen_gender(),
  gen_race(),
  gen_state(),
  .id = FALSE
) %>% arrange(id)

data %>% kable(format = "html")
```
</div><p></p>

```{r find duplicates}
result <- to_be(data, view_duplicated, id)
```

The duplicated id entries:

{% highlight r %}
result[["to_be"]]
{% endhighlight %}
<div class = "dftab">
```{r to be, echo = FALSE}
x <- result[["to_be"]]
rownames(x) <- NULL
x %>% kable(format = "html")
```
</div><p></p>

The non-duplicated id entries:

{% highlight r %}
result[["not_to_be"]]
{% endhighlight %}
<div class = "dftab">
```{r not to be, echo = FALSE}
y <- result[["not_to_be"]] 
rownames(y) <- NULL
y %>% kable(format = "html")
```
</div><p></p>

Keep the id that corresponds to a female or someone greater than 50 years old.

{% highlight r %}
result[["to_be"]] %>% arrange(gender, desc(age)) %>% group_by(id) %>% slice(1)
{% endhighlight %}
<div class = "dftab">
```{r, echo = FALSE}
z <- x %>%
  arrange(gender, desc(age)) %>% 
  group_by(id) %>% 
  slice(1) 
z %>% kable(format = "html")
```
</div><p></p>

Now combine the results back together.

{% highlight r %}
# obtain the duplicated entries
result[["to_be"]] %>% 
  # order by gender (females first) and decreasing age
  arrange(gender, desc(age)) %>% 
  # group by unique id's
  group_by(id) %>% 
  # take the first entry in each group
  do(slice(.,1)) %>% 
  # combine results with non-duplicated data
  rbind(result[["not_to_be"]])
{% endhighlight %}

<div class = "dftab">
```{r, echo = FALSE}
a <- result[["to_be"]] %>% 
  arrange(gender, desc(age)) %>% 
  group_by(id) %>% 
  do(slice(.,1)) %>% 
  rbind(result[["not_to_be"]]) %>% 
  data.frame %>% 
  arrange(id)
rownames(a) <- NULL
a %>% kable(format = "html")
```
</div>

[package_link]: https://github.com/jnguyen92/jn.general
