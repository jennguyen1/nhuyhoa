---
layout: post
title: "SAS Basics"
date: "July 26, 2015"
categories: ['basics']
---

* TOC
{:toc}

```{r, echo = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(eval = FALSE)
```

# Working with Data

## Import Data

**Manually**
```{r}
data DATANAME;
input VARNAMES ($);
datalines;
DATA;
run;
```

**CSV Files**
```{r}
data DATANNAME;
infile "FILEPATH" dlm = ',' startobs = 2 dsd;
input VARNAMES @@;
run;
```

```{r}
proc import datafile = "FILEPATH" out = DATANAME dbms = csv replace;
getnames = yes;
datarow = 2;
guessingrows = 1000;
run;
```

**From Existing Table**
```{r}
data DATANAME;
set DATASET;
```

## Export Data

**To CSV**
```{r}
proc export data = DATANAME outfile = "FILEPATH" dbms = csv replace;
run;
```

**Print Data**
```{r}
proc print data = DATANAME noobs;
```


## Edit Data

Shortcuts may be used to select many columns

* `VAR1-VAR10`: VAR1, VAR2, ..., VAR10
* `_ALL_`, `_CHARACTER_`, `_NUMERIC_`: all variables of specified type

**Creating a New Column**
```{r}
data DATANAME;
set DATANAME;
NEWCOL = EXPR;
run;
```

To change the format of variables

* Numeric to character conversion: `put(VALUE, $32.)`
* Character to numeric conversion: `input(VALUE, best32.)`
* Missing data is represented by a dot `.`

Other expressions of interest

* `=`, `^=`, `>`, ...
* `&`, `|`, `not` 
* `is missing`, `is not missing`, `is null`
* `n()`, `nmiss()`
* `between __ and __`, `contains`, `in (..., ..., ...)`

**Renaming Columns**
```{r}
data DATANAME;
set DATANAME;
rename OLD = NEW;
run;
```

**Reorder Columns**
```{r}
data DATANAME;
retain CORRECT.COL.ORDER;
set DATANAME;
run;
```

**Keep/Drop Columns**
```{r}
data DATANAME;
set DATANAME;
drop COL1 COL2 ...;
keep COL3 COL4 ...;
run;
```

**Keep/Delete Observations**
```{r}
# to keep add the phrase
if CONDITION;

# to delete add the phrase
if CONDITION then delete;
```

**Sorting Data**
```{r}
proc sort data = INDATA out = OUTDATA sortseq = __ nodupkey;
by ascending/descending VAR1 VAR2;
run;
```

There are several options for sorting

* `ASCI`: sorts by blanks, numbers, uppercase, lowercase
* `LINGUISTIC(STRENGTH = PRIMARY)`: sorts in ASCI, ignoring case
* `LINGUISTIC(NUMERIC_COLLATION = ON)`: treats numbers as numbers and not just digits
* `nodupkey`: removes duplicate keys

## Using SQL in SAS
```{r}
proc sql outobs = N print;
create table NEWTABLE as 
select COLNAMES/EXPRESSION as NEWNAME
into :MACRONAME separated by ""
from TABLE
where CONDITION
group by COLNAMES
having EXPRESSION
order by COLNAMES ASC/DCS;
quit;
```

Can also do SQL joins in SAS
```{r}
proc sql;
select * 
from TAB1
inner join TAB2
where TAB1.id = TAB2.id;
quit;
```

There are a number of functions for `proc sql` in addition to the usual SAS and SQL functions including

* `missing( A )`
* `monotonic()` refers to the row number
* `ifc( CONDITION, YES, NO )` if/else for character results
* `ifn( CONDITION, YES, NO )` if/else for numeric results

And the following aggregate functions

* `unique( A )`
* `nmiss( A )`
* `var( A )`
* `std( A )`
* `stderr( A )`
* `range( A )`
* `sumwgt( A )`
* `t( A )` t-value from one-sided t-test
* `prt( A )` two-tailed p-value for t-statistic

# Conditionals
The basic statement for if and else are

```{r}
if CONDITION then EXPRESSION;
else if CONDITION then EXPRESSION;
else EXPRESSION;
```

# Loops

**For Loops**
```{r}
do i = START to STOP by INCREMENT;
  OPERATIONS;
end;

do i = 1, 2, 3, 4 to 10 by INCREMENT;
  OPERATIONS;
end;
```

Using an `output` statement inside a loop creates a new row/observation based on the current iteration of the loop.

**While and Until Loops**
```{r}
do while(CONDITION);
  OPERATIONS;
end;

do until(CONDITION);
  OPERATIONS;
end;
```

**Control within Loops**

* Skip to next iteration: `continue`
* Exit loop: `leave`

# Arrays

Arrays are useful for iterating over variables and performing repetitive tasks. 

Arrays can be defined with the statement
```{r}
array ARRNAME(DIM) ELEM1 ELEM2 ELEM3 ... ELEMN;
```

Arrays may also be initialized with the appropriate dimensions and edited later to create new columns
```{r}
array ARRNAME(DIM);
```

Once declared, use a loop to iterate through an array and edit single elements as needed. The dimensions of an array can be accessed with `dim(ARRNAME)`.

There are several shortcuts to choose variables to incorporate into an array

* `__ALL__`
* `__CHARACTER__`
* `__NUMERIC__`
* `var1-varn`: variable named `var1`, `var2`, ..., `varn`

Below is an example
```{r}
data temps;
  set temps;
  input City $ 1-18 m1 m2 m3 m4 m5 m6 m7 m8 m9 m10 m11 m12;
	array fahr(*) m1-m12;
	do i = 1 to 12;
	      fahr(i) = 1.8*fahr(i) + 32;  	
    end;
run;
```

# Macros

## Declare Macro Variables
```{r}
%LET MNAME = VALUE;
```

Data values can be converted into macro variables with
```{r}
call symput("MNAME", VALUE);
```

**Declaring Macrovariables with Proc SQL**

Macrovariables can also be created from `proc sql`.

The following statement selects the first row of the column into a macrovariable 
```{r}
select country, flower into :country1, :flower1
```

This can be done with and without aggregation. 

Select multiple rows and create multiple macrovariables with
```{r}
%let n = 100
select country, flower into :country1 - :country&n, :flower1 - :flower&n
```

All the values with a column may be concatenated into a single macrovariable with
```{r}
select country into :countries separated by ", "
```

## Use Macro Variable

```{r}
&MNAME
```

When used in a string, macrovariables should start with a `&` and end with a space, `;`, `&`, or `.`

There are a number of built-in macrovariables, including

* `&sysdate`, `&sysdate9`
* `&ststime`
* `&sysday`

To write macrovariables to the console, write
```{r}
%put &MNAME;
```

Macrovariables may also be concatenated to form the name of another macrovariable. This may be useful in looping. For example,
```{r}
%let var5 = 10
%let i = 5

%put &&var&i
```

## Conditional
```{r}
%if CONDITION %then ACTION;
%else %if CONDITION %then ACTION;
%else ACTION;

%if CONDITION %then %do;
  OPERATIONS;
%end;
```

## Loops
```{r}
%do i = START %to STOP;
  OPERATIONS;
%end
```

## Functions
```{r}
%macro MACRONAME(param1 = , param2 = , ...);
  OPERATIONS;
%mend MACRONAME;

%MACRONAME(PARAMS);
```

The parameters of macros are macro variables, so access them with `&`.
